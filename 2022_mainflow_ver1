import cv2
import numpy as np
import serial
from time import sleep

ser = serial.Serial('COM14', 9600)
motorOutput = ""
taskOutput = "900000"
motorOrTask = True 	#decide to send which output to arduino (true motor/ false task)
signCode = 0
signCounter = 0
colorCounter = 0
pixelcount = []
for i in range(640):
    pixelcount.append(0)

rf = Roboflow(api_key="9TAvQYtv7pJPJpRoNOrh")
project = rf.workspace().project("fruit_detect_model_2.0")
model = project.version(1).model
#						sign 			pot 			tube 		   red 			yellow 			blue 			black
maskLowwerBound = [[  3,177,164], [  0,  85,  67], [  0,121,121], [255,255,255], [255,255,255], [255,255,255], [255,255,255]]
maskUpperBound  = [[ 57,255,234], [ 15, 255, 255], [ 11,255,255], [255,255,255], [255,255,255], [255,255,255], [255,255,255]]
maskName = dict.fromkeys(['signMask', 'potMask', 'tubeMask', 'redSideMask', 'yellowSideMask', 'blueSideMask', 'blackSideMask', 'redWaterMask', 'yellowWaterMask', 'blueWaterMask', 'blackWaterMask']) 
state = 0

def maskAll():	#process masks	input: three caps/ output: eleven masked img (sign, pot, tube, 4 colors)
	frontHsv=cv2.cvtColor(frontFrame,cv2.COLOR_BGR2HSV)
	sideHsv=cv2.cvtColor(sideFrame,cv2.COLOR_BGR2HSV)
	waterHsv=cv2.cvtColor(waterFrame,cv2.COLOR_BGR2HSV)
	for i in range(3):	#mask sign, pot, tube
	    mask = cv2.inRange(frontHsv,np.array(maskLowwerBound[i]),np.array(maskUpperBound[i]))
	    maskName[list(maskName)[i]] = cv2.bitwise_and(frontHsv,frontHsv,mask=mask)
	for i in range(3, 7):	#mask side four color
		mask = cv2.inRange(sideHsv,np.array(maskLowwerBound[i]),np.array(maskUpperBound[i]))
	    maskName[list(maskName)[i]] = cv2.bitwise_and(sideHsv,sideHsv,mask=mask)
	for i in range(7, 11):	#mask water four color
		mask = cv2.inRange(waterHsv,np.array(maskLowwerBound[i-4]),np.array(maskUpperBound[i-4]))
	    maskName[list(maskName)[i]] = cv2.bitwise_and(waterHsv,waterHsv,mask=mask)

def signDetect():	#input: mask sign img/ output: (int)signCode (0: None, 1: left tri, 2: right tri, 3: square, 4: circle) and return True
    contours, hierarchy = cv2.findContours(maskName['signMask'], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)  # 回傳兩個值，第一個值是輪廓，第二個值是階層
    # x,y,w,h=-1,-1,-1,-1
    for cnt in contours:
        # print(cnt)#輪廓點的數字,顯示在run的結果
        area = cv2.contourArea(cnt)  # 輪廓面積
        if area > 10000:  # 扣除雜訊
            peri = cv2.arcLength(cnt, True)  # 輪廓邊長(輪廓,輪廓是否閉合)
            vertices = cv2.approxPolyDP(cnt, peri * 0.02, True)  # 用多邊形近似輪廓(輪廓,近似值,輪廓是否閉合)會回傳多邊形頂點
            corners = len(vertices)  # 有幾個頂點
            x, y, w, h = cv2.boundingRect(vertices)  # 回傳四個值:左上角的x、左上角的y值、寬度、高度
            cv2.drawContours(signShow, cnt, -1, (0, 255, 0), 3)  # (畫在哪,要畫的輪廓,要畫的輪廓是第幾個-1表每一個都畫,顏色,粗度)
            if corners==3:#是個三角形
                #cv2.putText(signShow,"triangle",(x,y-5),cv2.FONT_HERSHEY_SIMPLEX,1,(0,255,0),2)
                newapp = np.ravel(vertices)
                flag_y, flag_x, sec_y, sec_x = 0
                for i in range(1, len(newapp), 2):
                    if newapp[i] > flag_y:
                        sec_y = flag_y
                        sec_x = flag_x
                        flag_y = newapp[i]
                        flag_x = newapp[i - 1]
                    elif newapp[i] > sec_y:
                        sec_y = newapp[i]
                        sec_x = newapp[i - 1]
                if flag_x >= sec_x:
                    cv2.putText(signShow, "left", (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                    signCode = 1
                    return True
                elif flag_x <= sec_x:
                    cv2.putText(signShow, "right", (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                    signCode = 2
                    return True
            elif corners == 4: #是個正方形
                cv2.putText(signShow, "rectangle", (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                signCode = 3
                return True
            elif corners == 8:  # 是個正方形
                cv2.putText(signShow, "circle", (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                signCode = 4
                return True
    return False

def potDetect():	#input: mask pot img/ output: (change global variable) motorOutput
	turnratio = 0.3
    firstcoor = -1
    upbound = 120
    lowbound = 280
    boundary = [0, 0, 0, 0]
    for i in range(0, 640):
        pixel = 0
        pixelcount[i] = 0
        num = np.uint8(0)
        #chop the image
        for j in range(upbound, lowbound):
            if (potMask[j][i][0] != num or potMask[j][i][1] != num or potMask[j][i][2] != num): 
            	pixel += 1
        if pixel > 25:
            pixelcount[i] = pixel
        #clear if continuous density too small
            if firstcoor == -1:
                firstcoor = i
        elif firstcoor != -1:
            if i - firstcoor < 10:
                for j in range(firstcoor, i):
                    pixelcount[j] = 0
            firstcoor = -1
        #find range for left and right
        if i < 320:
            if pixelcount[i] != 0:
                if boundary[0] == 0:
                    boundary[0] = i
                else:
                    boundary[1] = i
        elif i >= 320:
            if pixelcount[i] != 0:
                if boundary[2] == 0:
                    boundary[2] = i
                else:
                    boundary[3] = i
    leftdiff = boundary[1] - boundary[0]
    rightdiff = boundary[3] - boundary[2]
    moveratio = (leftdiff-rightdiff)*turnratio
    #show density
    for i in range(640):
        if pixelcount[i] != 0:
		    potMask = cv2.line(potMask, (i, 480), (i, 480-pixelcount[i]), (255, 255, 0), 1)
		    potMask = cv2.line(potMask, (boundary[0], 480), (boundary[0], 0), (0, 0, 255), 1)
		    potMask = cv2.line(potMask, (boundary[1], 480), (boundary[1], 0), (0, 0, 255), 1)
		    potMask = cv2.line(potMask, (boundary[2], 480), (boundary[2], 0), (0, 0, 255), 1)
		    potMask = cv2.line(potMask, (boundary[3], 480), (boundary[3], 0), (0, 0, 255), 1)
		    potMask = cv2.line(potMask, (0, upbound), (640, upbound), (0, 0, 255), 1)
		    potMask = cv2.line(potMask, (0, lowbound), (640, lowbound), (0, 0, 255), 1)
    if abs(leftdiff-rightdiff) < 25:
        cv2.putText(potMask, "go straight", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    elif leftdiff > rightdiff:
        cv2.putText(potMask, "turn right", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    else:
        cv2.putText(potMask, "turn left", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    left = 128 + moveratio 
    right = 128 - moveratio
    left_str = str(int(left))
    right_str = str(int(right))
    if right < 100:
        right_str = '0' + right_str
    if left < 100:
        left_str = '0' + left_str
    motorOutput = left_str + right_str +'\n'
    print('boundary:', boundary)
    print('leftdiff:', leftdiff, 'rightdiff:', rightdiff)
    print(motorOutput)
    cv2.imshow('cup', potMask)

def colorDetect():	#input: four color mask img/ output: (change global variable) colorSign and return True

def fruitDetect():	#input: four color mask img/ output: loop until get fruit and return True
	fruitFrame = cv2.resize(sideFrame, (0, 0), fx=1.2, fy=1.2)
    cv2.imwrite('fruitFrame.jpg',fruitFrame)
    prediction = model.predict('fruitFrame.jpg', confidence=40, overlap=30)
    # cv2.imshow('video', frame)
    # infer on a local image
    print(prediction.json())
    print(prediction)
    print(prediction.plot())

    for i in range (len(prediction)) :
        if(prediction[i]["class"] == queryfruit):
            x = prediction[i]["x"]
            y = prediction[i]["y"]
            width = prediction[i]["width"]
            height = prediction[i]["height"]
            volume = width*height
            print('x:', x, ' y:',y)
            print('volume:', volume)

def waterDetect():	#input: four color mask img/ output: loop until water

def tubeDetect():	#input: mask tube img/ output: (change global variable) motorOutput
	turnratio = 0.1
	upbound = 120
    lowbound = 280
    boundary = [0, 0, 0, 0]
    luCounter = 0
    llCounter = 0
    ruCounter = 0
    rlCounter = 0
    for i in range(0, 320):
        num = np.uint8(0)
        #chop the image
        if boundary[0] == 0:
            if (tubeMask[upbound][i][0] != num or tubeMask[upbound][i][1] != num or tubeMask[upbound][i][2] != num):
                if luCounter > 2:
                    boundary[0] = i
                    cv2.circle(tubeMask, (i, upbound), 5, (255, 204, 0), -1)
                else :
                    luCounter += 1
            else:
                luCounter = 0
        if boundary[1] == 0:
            if (tubeMask[lowbound][i][0] != num or tubeMask[lowbound][i][1] != num or tubeMask[lowbound][i][2] != num):
                if llCounter > 2:
                    boundary[1] = i
                    cv2.circle(tubeMask, (i, lowbound), 5, (255, 204, 0), -1)
                else :
                    llCounter += 1
            else:
                llCounter = 0
    for i in range(320, 640):
        num = np.uint8(0)
        #chop the image
        if boundary[2] == 0:
            if (tubeMask[upbound][i][0] != num or tubeMask[upbound][i][1] != num or tubeMask[upbound][i][2] != num):
                if ruCounter > 2:
                    boundary[2] = i
                    cv2.circle(tubeMask, (i, upbound), 5, (255, 204, 0), -1)
                else :
                    ruCounter += 1
            else:
                ruCounter = 0
        if boundary[3] == 0:
            if (tubeMask[lowbound][i][0] != num or tubeMask[lowbound][i][1] != num or tubeMask[lowbound][i][2] != num):
                if rlCounter > 2:
                    boundary[3] = i
                    cv2.circle(tubeMask, (i, lowbound), 5, (255, 204, 0), -1)
                else :
                    rlCounter += 1
            else:
                rlCounter = 0
        
    leftdiff = abs(boundary[1] - boundary[0])
    rightdiff = abs(boundary[3] - boundary[2])
    print('boundary:', boundary)
    print('leftdiff:', leftdiff, 'rightdiff:', rightdiff)
    moveratio = (leftdiff-rightdiff)*turnratio
    cv2.line(tubeMask, (0, upbound), (640, upbound), (0, 0, 255), 1)
    cv2.line(tubeMask, (0, lowbound), (640, lowbound), (0, 0, 255), 1)
    if abs(leftdiff-rightdiff) < 20:
        cv2.putText(tubeMask, "go straight", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    elif leftdiff > rightdiff:
        cv2.putText(tubeMask, "turn right", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    else:
        cv2.putText(tubeMask, "turn left", (10, 480-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (255, 255, 255), 2)
    left = 128 + moveratio 
    right = 128 - moveratio
    left_str = str(int(left))
    right_str = str(int(right))
    if right < 100:
        right_str = '0' + right_str
    if left < 100:
        left_str = '0' + left_str
    motorOutput = left_str + right_str +'\n'
    print(motorOutput)

def potAndSign(currentState):
	potDetect()
		if signDetect():
			if signCounter > 3:		# counter to be tested
				motorOrTask = False
				state = currentState + 1
				signCounter = 0
			else:
				signCounter += 1
		else:
			signCounter = 0

def potAndColor(currentState):
	potDetect()
		if colorDetect():
			if colorCounter > 3:
				state = 1 + currentState
				colorCounter = 0
			else:
				colorCounter += 1
		else:
			colorCounter = 0

def switch():
	if state == 0:
		potAndSign(state)
	elif state == 1:
		potAndColor(state)
	elif state == 2:
		potDetect()
		if fruitDetect():
			state = 3
	elif state == 3:
		potAndSign(state)
	elif state == 4:
		potAndSign(state)
	elif state == 5:
		potAndColor(state)
	elif state == 6:
		potDetect()
		if waterDetect():
			state = 7
	elif state == 7:
		potAndSign(state)
	elif state == 8:
		potAndSign(state)
	elif state == 9:
		tubeDetect()

frontCap = cv2.VideoCapture(0)
sideCap = cv2.VideoCapture(1)
waterCap = cv2.VideoCapture(2)

while True:
    ret1, frontFrame = frontCap.read()
    ret2, sideFrame = sideCap.read()
    ret3, waterFrame = waterCap.read()
    if ret1 and ret2 and ret3:
    	frontFrame = cv2.resize(frontFrame, (640, 480))
    	sideFrame = cv2.resize(sideFrame, (640, 480))
    	waterFrame = cv2.resize(waterFrame, (640, 480))
    	signShow = frontFrame.copy()
    	maskAll()
        switch()
 
        if motorOrTask:
        	ser.write(motorOutput.encode('utf-8'))
        else:
        	ser.write(taskOutput.encode('utf-8'))
        	motorOrTask = True

    while ser.in_waiting:
    	state = int(ser.readline().decode())

    if cv2.waitKey(1)==ord("q")
        break
frontCap.release()
sideCap.release()
waterCap.release()
cv2.destroyAllWindows()
